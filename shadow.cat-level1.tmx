<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="1.8.1_2"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN-US">
        <seg>Linux Magazine Column 94 (Jun 2007)</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Columna 94 del Linux Magazine (juny de 2007)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[suggested title: ``The Moose is Flying (part 1)'']</seg>
      </tuv>
      <tuv lang="CA">
        <seg>[títol suggerit: «El Moose està volant (1a part)»]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's object system is very ``flexible'', meaning, you get to build it from the ground up.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El sistema d'objectes de Perl és molt «flexible», és a dir, es construeix de baix cap a dalt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can build traditional hash-based objects, or more exotic array-based or inside-out objects.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podeu construir objectes tradicionals basats en taules de dispersió, o objectes més exòtics basats en matrius o objectes capgirats.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And then you have to create the accessors, define access policies, and perform a lot of repetitive code.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Aleshores heu de crear els mètodes accessors, definir les polítiques d'accés i generar un munt de codi repetit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Luckily, Perl is introspective enough that you can get Perl to do most of the hard boring work.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Afortunadament, Perl és prou introspectiu com perquè li encomaneu la majoria del treball dur i avorrit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has resulted in a number of ``class frameworks'' finding their way onto the CPAN.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això ha provocat que un bon nombre «d'entorns de treball per a classes» hagin estat publicats al CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Moose framework appeared about a year ago, and I initially dismissed it as ``yet another class framework'', much in the same way as I feel about yet another templating system or object-relational mapper.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>L'enton de treball Moose va sorgir fa un any i inicialment jo el vaig descartar com «un altre entorn de treball per a classes», de la mateixa manera que un altre sistema de plantilles o un altre mapeig d'objectes relacional em fan sentir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, I recently took a look at what Moose had become, and was pleasantly surprised.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tanmateix, vaig fer un cop d'ull recentment al que s'havia convertit Moose i em vaig endur una sorpresa agradable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As I started playing with it, I exclaimed frequently that this framework would have saved me quite a bit of time on some past projects, such as the text I wrote for our Intermediate Perl course and book, parts of which have been included as the perlboot manpage in the distribution.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Així que em vaig posar a jugar-hi, sovint vaig exclamar que aquest entorn de treball m'hauria estalviat un bona pila de temps en alguns projectes passats, com ara el text que vaig escriure per al nostre curs i llibre Intermediate Perl, algunes parts del qual s'han inclòs com la pàgina de manual perlboot a la distribució.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's recreate the ``animal'' classes from that text, using Moose, to see how this emerging framework simplifies things.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Posem-nos a refer les classes «d'animals» d'aquell text utilitzant Moose per veure com aquest entorn de treball emergent simplifica les coses.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, we'll create a horse class in Horse.pm that has a name and a color:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Primer crearem la classe cavall a Horse.pm que té un nom i un color:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bringing in Moose defines has, which takes the name of an attribute along with its properties.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Incorporant Moose es defineix has, al qual se li passa el nom d'un atribut juntament amb les seves propietats.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we're saying that the two attributes are ``read/write''.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest cas, diem que els dos atributs són de «lectura/escriptura».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can now use this class:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara podem utilitzar aquesta classe:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that I didn't have to define a new method: Moose does that for me.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fixeu-vos que no m'ha calgut definir un mètode new: Moose ho fa per mi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now in the original text, Horse inherited from Animal.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En el text original Horse heretava d'Animal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can do that rather simply.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem fer això molt fàcilment.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Animal.pm, we place:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Posem a Animal.pm:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And then update our Horse.pm:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I aleshores actualitzem el nostre Horse.pm:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that extends here replaces the traditional use base and completely sets @ISA, rather than adding to it.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fixeu-vos que aquí extends substitueix el tradicional use base i fixa completament @ISA, enlloc d'afegir-hi un element.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It's possible that you might want to put this inside a BEGIN block, although I've not seen any examples requiring it yet.)</seg>
      </tuv>
      <tuv lang="CA">
        <seg>(És possible que vulgueu posar això dins d'un bloc BEGIN, tot i que encara no he vist cap exemple que ho necessiti).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, Horse and Animal are identical.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest punt, Horse i Animal són idèntics.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can both be instantiated, and have the two given attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els dos es poden instanciar i se'ls pot assignar atributs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the original example, what distinguished a horse was the sound it made, which we can add here:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En l'exemple original, el que distingia un cavall era el so que feia, cosa que podem afegir aquí:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then reference that in the common speak method in Animal:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>i aleshores fer-hi referència al mètode comú speak d'Animal:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the use of confess, another freebie from Moose.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fixeu-vos en l'ús de confess, un altre regal de Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the derived class hasn't defined a sound, I want to complain.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si la classe derivada no ha definit un so, vull queixar-me.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But since Horse defines sound, I'll never see that for a horse.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Però com que Horse defineix sound, no veure mai això per un cavall.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this code, I can create my classic talking horse:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb aquest codi puc crear el meu clàssic cavall parlador:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, I'm still coding things that would be simple without Moose, so let's start diverging a bit to see the full power.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins ara només estic programant coses que serien senzilles sense Moose, així que comencem a fer alguns canvis per veure'n tot el poder.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, an Animal is really an abstract class, being used only to provide common attributes and methods to a concrete class (in this case, the horse class).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Primer, un Animal és en realitat una classe abstracta, utilitzada només per proveïr atributs i mètodes comuns per a una classe concreta (en aquest cas, la classe cavall).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Moose-terminology, this can best be described as a role.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En la terminologia de Moose això es descriu millor com un rol.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role is like a mix-in, providing a collection of attributes and methods that use those attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol és com un mix-in, que proveeix una col·lecció d'atributs i mètodes que utilitzen aquells atributs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role never has any instances, because it's not a complete class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol mai té cap instància perquè no és una classe completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When we make Animal a role, we'll also get some additional support:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Quan fem que Animal sigui un rol també obtenim suport addicional:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that we've replaced the confess-including stub with requires.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fixeu-vos que hem substituït l'«stub» que incloïa el confess per un requires.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This informs Moose that this role must now be used with a class that provides the sound method, which will be checked at compile-time.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això informa a Moose que les classes que usin aquest rol han de proveir el mètode sound, que serà verificat en temps de compilació.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To pull in a role, we use with rather than extends:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per atorgar un rol utilitzem with enlloc d'extends:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Had we failed to include sound, we'd get notification very early on.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si ens haguéssim oblidat d'incloure sound hauríem rebut un avís de bon començament.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cool.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Genial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, Horse otherwise still works as before.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest punt, Horse segueix funcionant com abans.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What about those with and requires keywords?</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Què passa amb les paraules clau with i requires?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because they're defined by the Moose and Moose::Role imports, they remain as part of the package.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Com que estan definits per les importacions de Moose i Moose::Role, romandran com a part del paquet.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the purists in us who don't like that kind of pollution, we can throw them away when we're done, using the correponding no keyword (similiar to use strict and no strict).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per als puristes com nosaltres als que no ens agrada aquest tipus de pol·lució, podem eliminar-los quan hàgim acabat utilitzant la paraula clau no (de forma similar a use strict i no strict).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, we'd clean up Horse.pm with:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, podem netejar Horse.pm amb:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And similarly, Animal.pm requires no Moose::Role at the end.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I de forma similar, Animal.pm necessita no Moose::Role al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose supports the notion of a default value.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Moose ofereix suport per a la noció de valor predeterminat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's add in the default color, and make that a class responsibility as well:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Afegim el color predeterminat i fem que això també sigui responsabilitat de la classe:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the color isn't provided, the default color of the class will be consulted, and requires ensures that the concrete class provides this default color.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si no s'indica el color, es consultarà el color predeterminat de la classe i requires garanteix que la classe concreta proveeix aquest color predeterminat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our derived animal classes now look like:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Les nostres classes derivades ara tenen aquest aspecte:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now we can count sheep as one of our implemented classes:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara «ovella» és una més de les nostres classes implementades:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, this is pretty straightforward.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Bé, això és força pim pam.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's solve a few other problems from the original material.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Anem a resoldre alguns dels altres problemes del material original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Mouse class was special, because it extended the speak method with an additional line of output.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>La classe Mouse era especial perquè extenia el mètode speak amb una línia addicional de sortida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While we could use traditional SUPER::-based method calls to call parent-class behaviors, this doesn't work with roles.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tot i que podríem utilitzar els mètodes tradicionals basats en SUPER:: per cridar els comportaments de la classe pare, això no funciona amb els rols.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Roles don't end up in @ISA, because they're ``glued in'' rather than ``tacked above''.)</seg>
      </tuv>
      <tuv lang="CA">
        <seg>(Els rols no acaben dins de @ISA perquè estan «empegats per dins» enlloc d'«enganxats al damunt»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Luckily, Moose provides the convenient after call to append additional steps to an existing subroutine.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Afortunadament, Moose ofereix convenientment la crida after per afegir passes addicionals al final d'una subrutina existent.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose does this by replacing the original subroutine with a new subroutine that calls the original routine and then calls the additional code.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Moose fa això substituint la subrutina original per una nova subrutina que crida l'orginal i tot seguit crida al codi addicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The context (list, scalar, or void) is properly preserved, as is the original return value.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El context (llista, escalar, o buit) es conserva de forma adequada, així com també el valor de retorn original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our amended speak looks something like:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El nostre speak retocat té aquesta pinta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives us a properly functioning mouse:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això ens dóna un ratolí que funciona correctament:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which results in:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>que dóna com a resultat:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can also use before and around to precede the original behavior or control the calling of the original behavior, as necessary.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>També podem utilitzar before per a precedir el comportament original o around per a controlar com es crida el comportament original, segons calgui.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to allow name to be used as both an accessor and still return an unnamed Horse when used as a class method, we can ``around'' the resulting name accessor:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, per a permetre que name s'utilitzi com un mètode accessor però que segueixi retornant an unnamed Horse quan s'utilitzi com un mètode de classe, podem posar un «around» del mètode accessor resultant:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The has creates the original behavior.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El has crear el comportament original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The around intercepts the original subroutine name, causing the original coderef to be passed as the first parameter to this new subroutine, which we capture in $next.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>L'around intercepta el nom de la subroutina original, fent que la referència al codi original es passi com a primer paràmetre d'aquesta nova subrutina, que nosaltres capturem a $next.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original $self is shifted away, and tested to see if it's an object or not, via blessed (conveniently exported via Moose).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Desencuem el $self original i el verifiquem per veure si és un objecte o no, via blessed (exportat per Moose convenientment).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a blessed object, we get the original behavior (a getter or setter), but for a class, we'll get the literal string.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per a un objecte obtenim el comportament original (un «getter» o «setter»), però per a una classe obtindrem la cadena literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What if we never gave our animal a name?</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Què passa si no li posem un nom al nostre animal?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll get warnings about undefined values.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Obtindrem avisos sobre valors indefinits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can give a default name just as we did a default color:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem assignar un nom predeterminat tal com vam fer amb el color predeterminat:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, we'd want that around immediately following this step.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Novament, voldríem aquell around immediatament després d'aquest pas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we don't want people setting the color after the initial instance creation, we can declare the attribute as read-only:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si no volem que la gent canviï el color després de la creació inicial de la instància, declarem l'atribut no modificable:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now an attempt to set the color is aborted with Cannot assign a value to a read-only accessor....</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara un intent de canviar el color s'avortarà amb Cannot assign a value to a read-only accessor....</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we really wanted to have a way to occasionally set the color, we can define a separately named writer:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si realment volíem una manera de canviar el color ocasionalment, podem definir a banda un anomenat escriptor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, we can't change the color of a mouse directly:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>D'aquesta manera no podem canviar el color d'un ratolí directament:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But we can use our private name instead:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Però en canvi podem utilitzar un mètode privat:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By using a long name, we're less likely to accidentally call it, except where we intentionally want to change the color.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tot utilitzant un nom llarg és menys probable que el cridem accidentalment, a menys que tinguem la intenció de canviar el color.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's create a RaceHorse by adding ``race features'' to a Horse.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Anem a crear un RaceHorse afegint «característiques de carrera» a un Horse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, we define the ``race features'' as, yes, another role:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Primer definim «característiques de carrera» com, sí, un altre rol:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that since has is just a subroutine call, we can use traditional Perl control structures (here, a foreach loop).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Com que has és només una crida a una subrutina, fixeu-vos que podem utilitzar estructures de control tradicionals de Perl (aquí, un bucle foreach).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a bit of code, we've added another four attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb una mica de codi hem afegit uns altres quatre atributs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial value of 0 means we don't have to write separate initialization code in our constructor.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El valor inicial 0 significa que no ens caldrà escriure per separat codi d'inicialització al nostre constructor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we can add some accessors:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tot seguit podem afegir alguns mètodes accessors:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each call to won increments the number of wins.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Cada crida a won incrementa el número de victòries.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This would be simpler if we presumed that these objects are implemented as hashes (which they are by default), as:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això seria més senzill si assumíssim que aquests objectes s'implementen amb taules de dispersió (per defecte és així), com ara:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, by using the public interface (a method call), we could change the implementation later to inside-out objects or array-based objects without breaking this code.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tanmateix, utilitzant la interfície pública (una crida al mètode) podríem canviar més endavant la implementació amb objectes capgirats o objectes basats en matrius sense trencar aquest codi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is especially important when creating a generic role, which could be mixed in to any kind of object.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això és especialment important quan es crea un rol genèric, que es podria mesclar amb qualsevol tipus d'objecte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create the race horse, we just mix a horse with a racer:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per a crear la carrera de cavalls només cal que mesclem un cavall amb un corredor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And now we can ride the ponies:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I ara ja podem cavalcar els ponis:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, I've just scratched the surface of what Moose provides.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins ara només he rascat la superfície del que proporciona Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next month, I'll look at some of the more advanced features of Moose that help keep the complex things relatively simple.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El proper mes miraré algunes de les característiques més avançades de Moose que ajuden a mantenir les coses complexes de manera relativament simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until then, enjoy!</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins aleshores, gaudiu!</seg>
      </tuv>
    </tu>
  </body>
</tmx>
