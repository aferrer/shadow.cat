<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="1.8.1_2"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN-US">
        <seg>Linux Magazine Column 94 (Jun 2007)</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Columna 94 del Linux Magazine (juny de 2007)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[suggested title: ``The Moose is Flying (part 1)'']</seg>
      </tuv>
      <tuv lang="CA">
        <seg>[títol suggerit: «El Moose està volant (1a part)»]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's object system is very ``flexible'', meaning, you get to build it from the ground up.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El sistema d'objectes de Perl és molt «flexible», és a dir, es construeix de baix cap a dalt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can build traditional hash-based objects, or more exotic array-based or inside-out objects.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podeu construir objectes tradicionals basats en taules de dispersió, o objectes més exòtics basats en matrius o objectes capgirats.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And then you have to create the accessors, define access policies, and perform a lot of repetitive code.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Aleshores heu de crear els mètodes accessors, definir les polítiques d'accés i generar un munt de codi repetit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Luckily, Perl is introspective enough that you can get Perl to do most of the hard boring work.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Afortunadament, Perl és prou introspectiu com perquè li encomaneu la majoria del treball dur i avorrit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has resulted in a number of ``class frameworks'' finding their way onto the CPAN.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això ha provocat que un bon nombre «d'entorns de treball per a classes» hagin estat publicats al CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Moose framework appeared about a year ago, and I initially dismissed it as ``yet another class framework'', much in the same way as I feel about yet another templating system or object-relational mapper.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>L'enton de treball Moose va sorgir fa un any i inicialment jo el vaig descartar com «un altre entorn de treball per a classes», de la mateixa manera que un altre sistema de plantilles o un altre mapeig d'objectes relacional em fan sentir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, I recently took a look at what Moose had become, and was pleasantly surprised.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tanmateix, vaig fer un cop d'ull recentment al que s'havia convertit Moose i em vaig endur una sorpresa agradable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As I started playing with it, I exclaimed frequently that this framework would have saved me quite a bit of time on some past projects, such as the text I wrote for our Intermediate Perl course and book, parts of which have been included as the perlboot manpage in the distribution.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Així que em vaig posar a jugar-hi, sovint vaig exclamar que aquest entorn de treball m'hauria estalviat un bona pila de temps en alguns projectes passats, com ara el text que vaig escriure per al nostre curs i llibre Intermediate Perl, algunes parts del qual s'han inclòs com la pàgina de manual perlboot a la distribució.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's recreate the ``animal'' classes from that text, using Moose, to see how this emerging framework simplifies things.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Posem-nos a refer les classes «d'animals» d'aquell text utilitzant Moose per veure com aquest entorn de treball emergent simplifica les coses.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, we'll create a horse class in Horse.pm that has a name and a color:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Primer crearem la classe cavall a Horse.pm que té un nom i un color:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bringing in Moose defines has, which takes the name of an attribute along with its properties.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Incorporant Moose es defineix has, al qual se li passa el nom d'un atribut juntament amb les seves propietats.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we're saying that the two attributes are ``read/write''.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest cas, diem que els dos atributs són de «lectura/escriptura».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can now use this class:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara podem utilitzar aquesta classe:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that I didn't have to define a new method: Moose does that for me.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fixeu-vos que no m'ha calgut definir un mètode new: Moose ho fa per mi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now in the original text, Horse inherited from Animal.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En el text original Horse heretava d'Animal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can do that rather simply.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem fer això molt fàcilment.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Animal.pm, we place:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Posem a Animal.pm:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And then update our Horse.pm:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I aleshores actualitzem el nostre Horse.pm:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that extends here replaces the traditional use base and completely sets @ISA, rather than adding to it.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fixeu-vos que aquí extends substitueix el tradicional use base i fixa completament @ISA, enlloc d'afegir-hi un element.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It's possible that you might want to put this inside a BEGIN block, although I've not seen any examples requiring it yet.)</seg>
      </tuv>
      <tuv lang="CA">
        <seg>(És possible que vulgueu posar això dins d'un bloc BEGIN, tot i que encara no he vist cap exemple que ho necessiti).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, Horse and Animal are identical.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest punt, Horse i Animal són idèntics.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can both be instantiated, and have the two given attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els dos es poden instanciar i se'ls pot assignar atributs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the original example, what distinguished a horse was the sound it made, which we can add here:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En l'exemple original, el que distingia un cavall era el so que feia, cosa que podem afegir aquí:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then reference that in the common speak method in Animal:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>i aleshores fer-hi referència al mètode comú speak d'Animal:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the use of confess, another freebie from Moose.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fixeu-vos en l'ús de confess, un altre regal de Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the derived class hasn't defined a sound, I want to complain.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si la classe derivada no ha definit un so, vull queixar-me.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But since Horse defines sound, I'll never see that for a horse.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Però com que Horse defineix sound, no veure mai això per un cavall.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this code, I can create my classic talking horse:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb aquest codi puc crear el meu clàssic cavall parlador:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, I'm still coding things that would be simple without Moose, so let's start diverging a bit to see the full power.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins ara només estic programant coses que serien senzilles sense Moose, així que comencem a fer alguns canvis per veure'n tot el poder.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, an Animal is really an abstract class, being used only to provide common attributes and methods to a concrete class (in this case, the horse class).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Primer, un Animal és en realitat una classe abstracta, utilitzada només per proveïr atributs i mètodes comuns per a una classe concreta (en aquest cas, la classe cavall).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Moose-terminology, this can best be described as a role.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En la terminologia de Moose això es descriu millor com un rol.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role is like a mix-in, providing a collection of attributes and methods that use those attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol és com un mix-in, que proveeix una col·lecció d'atributs i mètodes que utilitzen aquells atributs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role never has any instances, because it's not a complete class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol mai té cap instància perquè no és una classe completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When we make Animal a role, we'll also get some additional support:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Quan fem que Animal sigui un rol també obtenim suport addicional:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that we've replaced the confess-including stub with requires.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fixeu-vos que hem substituït l'«stub» que incloïa el confess per un requires.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This informs Moose that this role must now be used with a class that provides the sound method, which will be checked at compile-time.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això informa a Moose que les classes que usin aquest rol han de proveir el mètode sound, que serà verificat en temps de compilació.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To pull in a role, we use with rather than extends:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per atorgar un rol utilitzem with enlloc d'extends:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Had we failed to include sound, we'd get notification very early on.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si ens haguéssim oblidat d'incloure sound hauríem rebut un avís de bon començament.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cool.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Genial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, Horse otherwise still works as before.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest punt, Horse segueix funcionant com abans.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What about those with and requires keywords?</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Què passa amb les paraules clau with i requires?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because they're defined by the Moose and Moose::Role imports, they remain as part of the package.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Com que estan definits per les importacions de Moose i Moose::Role, romandran com a part del paquet.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the purists in us who don't like that kind of pollution, we can throw them away when we're done, using the correponding no keyword (similiar to use strict and no strict).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per als puristes com nosaltres als que no ens agrada aquest tipus de pol·lució, podem eliminar-los quan hàgim acabat utilitzant la paraula clau no (de forma similar a use strict i no strict).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, we'd clean up Horse.pm with:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, podem netejar Horse.pm amb:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And similarly, Animal.pm requires no Moose::Role at the end.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I de forma similar, Animal.pm necessita no Moose::Role al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose supports the notion of a default value.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Moose ofereix suport per a la noció de valor predeterminat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's add in the default color, and make that a class responsibility as well:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Afegim el color predeterminat i fem que això també sigui responsabilitat de la classe:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the color isn't provided, the default color of the class will be consulted, and requires ensures that the concrete class provides this default color.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si no s'indica el color, es consultarà el color predeterminat de la classe i requires garanteix que la classe concreta proveeix aquest color predeterminat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our derived animal classes now look like:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Les nostres classes derivades ara tenen aquest aspecte:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now we can count sheep as one of our implemented classes:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara «ovella» és una més de les nostres classes implementades:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, this is pretty straightforward.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Bé, això és força pim pam.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's solve a few other problems from the original material.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Anem a resoldre alguns dels altres problemes del material original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Mouse class was special, because it extended the speak method with an additional line of output.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>La classe Mouse era especial perquè extenia el mètode speak amb una línia addicional de sortida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While we could use traditional SUPER::-based method calls to call parent-class behaviors, this doesn't work with roles.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tot i que podríem utilitzar els mètodes tradicionals basats en SUPER:: per cridar els comportaments de la classe pare, això no funciona amb els rols.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Roles don't end up in @ISA, because they're ``glued in'' rather than ``tacked above''.)</seg>
      </tuv>
      <tuv lang="CA">
        <seg>(Els rols no acaben dins de @ISA perquè estan «empegats per dins» enlloc d'«enganxats al damunt»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Luckily, Moose provides the convenient after call to append additional steps to an existing subroutine.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Afortunadament, Moose ofereix convenientment la crida after per afegir passes addicionals al final d'una subrutina existent.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose does this by replacing the original subroutine with a new subroutine that calls the original routine and then calls the additional code.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Moose fa això substituint la subrutina original per una nova subrutina que crida l'orginal i tot seguit crida al codi addicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The context (list, scalar, or void) is properly preserved, as is the original return value.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El context (llista, escalar, o buit) es conserva de forma adequada, així com també el valor de retorn original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our amended speak looks something like:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El nostre speak retocat té aquesta pinta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives us a properly functioning mouse:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això ens dóna un ratolí que funciona correctament:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which results in:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>que dóna com a resultat:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can also use before and around to precede the original behavior or control the calling of the original behavior, as necessary.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>També podem utilitzar before per a precedir el comportament original o around per a controlar com es crida el comportament original, segons calgui.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to allow name to be used as both an accessor and still return an unnamed Horse when used as a class method, we can ``around'' the resulting name accessor:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, per a permetre que name s'utilitzi com un mètode accessor però que segueixi retornant an unnamed Horse quan s'utilitzi com un mètode de classe, podem posar un «around» del mètode accessor resultant:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The has creates the original behavior.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El has crear el comportament original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The around intercepts the original subroutine name, causing the original coderef to be passed as the first parameter to this new subroutine, which we capture in $next.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>L'around intercepta el nom de la subroutina original, fent que la referència al codi original es passi com a primer paràmetre d'aquesta nova subrutina, que nosaltres capturem a $next.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original $self is shifted away, and tested to see if it's an object or not, via blessed (conveniently exported via Moose).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Desencuem el $self original i el verifiquem per veure si és un objecte o no, via blessed (exportat per Moose convenientment).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a blessed object, we get the original behavior (a getter or setter), but for a class, we'll get the literal string.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per a un objecte obtenim el comportament original (un «getter» o «setter»), però per a una classe obtindrem la cadena literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What if we never gave our animal a name?</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Què passa si no li posem un nom al nostre animal?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll get warnings about undefined values.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Obtindrem avisos sobre valors indefinits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can give a default name just as we did a default color:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem assignar un nom predeterminat tal com vam fer amb el color predeterminat:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, we'd want that around immediately following this step.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Novament, voldríem aquell around immediatament després d'aquest pas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we don't want people setting the color after the initial instance creation, we can declare the attribute as read-only:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si no volem que la gent canviï el color després de la creació inicial de la instància, declarem l'atribut no modificable:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now an attempt to set the color is aborted with Cannot assign a value to a read-only accessor....</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara un intent de canviar el color s'avortarà amb Cannot assign a value to a read-only accessor....</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we really wanted to have a way to occasionally set the color, we can define a separately named writer:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si realment volíem una manera de canviar el color ocasionalment, podem definir a banda un anomenat escriptor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, we can't change the color of a mouse directly:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>D'aquesta manera no podem canviar el color d'un ratolí directament:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But we can use our private name instead:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Però en canvi podem utilitzar un mètode privat:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By using a long name, we're less likely to accidentally call it, except where we intentionally want to change the color.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tot utilitzant un nom llarg és menys probable que el cridem accidentalment, a menys que tinguem la intenció de canviar el color.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's create a RaceHorse by adding ``race features'' to a Horse.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Anem a crear un RaceHorse afegint «característiques de carrera» a un Horse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, we define the ``race features'' as, yes, another role:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Primer definim «característiques de carrera» com, sí, un altre rol:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that since has is just a subroutine call, we can use traditional Perl control structures (here, a foreach loop).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Com que has és només una crida a una subrutina, fixeu-vos que podem utilitzar estructures de control tradicionals de Perl (aquí, un bucle foreach).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a bit of code, we've added another four attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb una mica de codi hem afegit uns altres quatre atributs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial value of 0 means we don't have to write separate initialization code in our constructor.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El valor inicial 0 significa que no ens caldrà escriure per separat codi d'inicialització al nostre constructor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we can add some accessors:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tot seguit podem afegir alguns mètodes accessors:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each call to won increments the number of wins.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Cada crida a won incrementa el número de victòries.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This would be simpler if we presumed that these objects are implemented as hashes (which they are by default), as:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això seria més senzill si assumíssim que aquests objectes s'implementen amb taules de dispersió (per defecte és així), com ara:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, by using the public interface (a method call), we could change the implementation later to inside-out objects or array-based objects without breaking this code.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tanmateix, utilitzant la interfície pública (una crida al mètode) podríem canviar més endavant la implementació amb objectes capgirats o objectes basats en matrius sense trencar aquest codi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is especially important when creating a generic role, which could be mixed in to any kind of object.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això és especialment important quan es crea un rol genèric, que es podria mesclar amb qualsevol tipus d'objecte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create the race horse, we just mix a horse with a racer:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per a crear la carrera de cavalls només cal que mesclem un cavall amb un corredor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And now we can ride the ponies:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I ara ja podem cavalcar els ponis:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, I've just scratched the surface of what Moose provides.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins ara només he rascat la superfície del que proporciona Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next month, I'll look at some of the more advanced features of Moose that help keep the complex things relatively simple.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El proper mes miraré algunes de les característiques més avançades de Moose que ajuden a mantenir les coses complexes de manera relativament simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until then, enjoy!</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins aleshores, gaudiu!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[suggested title: ``The Moose is Flying (part 2)'']</seg>
      </tuv>
      <tuv lang="CA">
        <seg>[títol suggerit: «El Moose està volant (2a part)»]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last month, I introduced the Moose object system by walking through the code developed in the perlboot manpage, rewriting it to use Moose.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El mes passat, vaig introduir el sistema d'objectes Moose recorrent el codi desenvolupat a la pàgina de manual de perlboot , reescrivint-ho per utilitzar Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Continuing from that discussion, let's look at some of the features I didn't cover last month.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Continuant a partir d'aquella discussió, fem un cop d'ull a algunes de les característiques que no vaig cobrir el mes passat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our Animal role included attributes of name, and color, and actions of speak and eat.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El nostre rol Animal incloïa atributs de name i color, i mètodes de speak i eat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can add a birthdate attribute to the mix with:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem afegir un atribut d'aniversari a la barreja amb:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As we don't want to be able to change the birthdate, we'll make it read-only.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Com que no volem que es pugui canviar la data d'aniversari, farem que sigui no modificable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, this attribute accepts any scalar, so these are all equally valid:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per defecte, aquest atribut accepta qualsevol escalar, així que aquests són tots equivalentment vàlids:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can get a bit of help from Moose to narrow down the permissible type of this new birthdate attribute using Moose's typing system:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem aconseguir una mica d'ajuda de Moose per reduir el tipus permès d'aquest nou atribut aniversari utilitzant el sistema de tipus de Moose:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The isa parameter here declares that the born parameter must be a DateTime object, or at least something that responds true to UNIVERSAL::isa($thing, &quot;DateTime&quot;).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El paràmetre isa declara aquí que el paràmetre  born  ha de ser un objecte DateTime, o com a mínim algun tipus que respongui cert a UNIVERSAL::isa($thing, &quot;DateTime&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now, if we try to put anything in this born attribute other than a DateTime, we get a run-time error.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara, si intentem assignar qualsevol cosa a l'atribut born que no sigui un DateTime, obtenim un error en temps d'execució.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So, this fails:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Així doncs, això falla:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But this succeeds:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Però això funciona:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DateTime string for isa refers here to the Perl class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>La cadena DateTime per isa es refereix aquí a la classe de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, we can also define this as an artificial Moose type:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tanmateix, també podem definir això com un tipus de Moose artificial:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This works like before, but now identifies DateTime as a Moose-type.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això funciona com abans, però ara identifica DateTime com un tipus de Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type is created by starting with any Object, and then requiring that this object pass the additional qualification of being a subclass of Perl's DateTime.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El tipus es crea començant amb qualsevol Object i després requering que aquest objecte passi la qualificació adicional de ser una subclasse de DateTime de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, we could continue to use this Moose-style DateTime type as we had before.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest punt, podem continuar utilitzant aquest DateTime de Moose com ho fèiem abans.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But once we've done this, we can further subtype the type.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una vegada hem fet això, podem derivar un subtipus del tipus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, we can require that the date be a historical date (before now):</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, podem requerir que la data sigui històrica (prèvia al present):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now, not just any DateTime will do.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara no funcionarà qualsevol DateTime.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has to be something that isn't in the future.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ha de ser algun moment que no sigui al futur.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression in where can be any expression returning a true/false value, using $_ as a proxy for the object in question.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>L'expressió al where pot ser qualsevol expressió que retorni un valor cert/fals, utilitzant $_ com a proxy per a l'objecte en qüestió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It'd be easier if we could still use casual forms like yesterday and 3/14/1929.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Seria més senzill encara si poguèssim utilitzar expressions informals com yesterday i 3/14/1929.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are both understood by Date::Manip.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Date::Manip enten aquestes dues.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We could parse the strings with Date::Manip, then pull out the component values and hand them to DateTime, but luckily, there's already a module to do that: DateTime::Format::DateManip.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem analitzar les cadenes amb Date::Manip, extreure els valors dels components i després entregar-los a DateTime, però afortunadament, ja hi ha un mòdul que fa això: DateTime::Format::DateManip.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not bad.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>No està malament.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our newbie horse is born yesterday, as we expect.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El nostre aprenent cavall va nèixer ahir, tal com esperàvem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But it'd be nice to just drop yesterday into the slot and have it do all of that for us.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Però estaria bé simplement posar yesterday al paràmetre i deixar que ho faci tot per nosaltres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And with coercions, we can.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I amb coercions, podem fer-ho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since passing a simple string as the birthtime is illegal, we can inform Moose that it should take that string and run it through DateTime::Format::DateManip automatically:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Com que passar una cadena com a aniversari no està permés, podem indicar a Moose que agafi la cadena i la passi per  DateTime::Format::DateManip automàticament:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The via code block takes $_ as the input value, which is expected to be a string (Str).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El bloc via agafa $_ com un valor d'entrada, que s'espera que sigui una cadena (Str).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last expression evaluated in the code is the new HistoricalDateTime value.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>L'última expressió avaluada al codi és el nou valor HistoricalDateTime.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We then permit this coercion to be used by adding coerce into the attribute declaration:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Després permetem l'ús d'aquesta coacció afegint coerce  a la declaració de l'atribut:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now, the born slot accepts either an explicit DateTime as before, or a simple string.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara el paràmetre born accepta o bé un DateTime explícit com abans, o bé una cadena simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string must be acceptable to Date::Manip, which will be used to convert the string into a DateTime object as our object is created.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>La cadena ha de ser acceptable per Date::Manip, que serà utilitzat per convertir la cadena a un objecte DateTime quan el nostre objecte sigui creat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, because the type constraint is still in place, the verification to ensure the result is a historical date is still active.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>A més, com que la coacció de tipus està a lloc, la verificació per assegurar que el resultat és una data històrica encara està activa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides the named classes and Str, Moose::Util::TypeConstraints also establishes types of things like Bool and HashRef.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>A més dels noms de les classes i Str, Moose::Util::TypeConstraints també estableix els tipus de coses com Bool i HashRef.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We could even have multiple coercions defined, as long as they are distinct.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins i tot podríem tenir múltiples coaccions definides, sempre i quan siguin diferents.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, we could use a hashref in the birthtime slot to indicate that we are passing key/value pairs to be handed to a DateTime constructor directly:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, podem utilitzar una referència a una taula de dispersió al paràmetre aniversari per indicar que estem passant parells clau/valor perquè siguin entregats directament a un constructor DateTime:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And now we can use a hashref to define the birthdate:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I ara podem definir una referència a una taula de dispersió per definir l'aniversari:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value for born is a DateTime, it's used directly.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si el valor per a born és un DateTime, s'utilitza directament.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's a string, it's passed to DateTime::Format::DateManip.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si és una cadena, es passa a DateTime::Format::DateManip.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if it's a hashref, it's passed directly as a flattened list to the DateTime constructor.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I si és una referència a una taula de dispersió, es passa directament com una llista aplanada al constructor DateTime.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Very cool.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Genial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value we specify for a default is subject to the same coercions and type checking.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El valor que especifiquem per a default està subjecte a les mateixes coaccions i comprovacions de tipus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can update born as:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem actualitzar born a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And now our animals default to being ``born yesterday''.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I ara, el valor per defecte dels animals a ``nascut ahir''.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the default value is still subject to the type constraints, so if we replace yesterday with tomorrow, the default value will be rejected properly.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Observeu que el valor per defecte encara està subjecte a les restriccions de tipus, per tant si substituïm yesterday per tomorrow, el valor per defecte serà rebutjat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the coercion happens as each object is created, so a default value of one minute ago will give us a new time each time it is called.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Observeu que la coacció passa a mesura que cada objecte es crea, per tant el valor per defecte one minute ago ens donarà una data diferent cada vegada que sigui cridat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While we're on things we can do to attributes, another interesting item is lazy.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Mentre estudiem què podem fer als atributs, un altre element interessant és lazy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the default value is expensive to compute, we can say ``don't really do this until you need to do it''.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si el valor per defecte és car de calcular, podem dir ``no facis això fins que ho necessitis''.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, turning yesterday into a DateTime is slightly expensive, so we can flag that as lazy:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, convertir yesterday a un objecte DateTime és una mica car, així que ho podem marcar com lazy:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Speaking of great support, as I was writing that last paragraph, I noticed a bug in the result, and chatting with Stevan on IRC got it fixed before I could turn this article in.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I parlant de suport fantàstic, mentre escrivia aquest últim pàrraf vaig descobrir un error de programació, i commentar-ho amb Stevan a l'IRC ho va solucionar abans que jo entregués l'article.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yeay.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Visca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anything built with Moose has a very high degree of introspection available.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Qualsevol cosa construïda amb Moose té disponible un grau molt alt d'introspecció.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, we can ask one of our animal friends to give us the meta object, with which we can make further requests:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, podem demanar a un dels nostres amics animals que ens doni l'objecte meta, amb el què podrem fer més peticions:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can ask the horse for the roles:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem demanar al cavall per els roles:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, we see that we've mixed in one role (of type Moose::Meta::Role, and get the name with:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest cas, veiem que hem obtingut un rol (de tipus Moose::Meta::Role), i aconseguit el nom amb:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which gives us Animal as we might expect.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>cosa que ens dona un Animal tal com esperàvem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can also ask the meta object for all applicable methods:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem demanar a l'objecte meta tots els mètodes aplicables:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which returns</seg>
      </tuv>
      <tuv lang="CA">
        <seg>cosa que retorna</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nice.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Genial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not sure what BEGIN is doing in there, but the rest are things that we've defined.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>No estic segur de què fa BEGIN aquí, però la resta són elements que hem definit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of these methods relate to the attributes, but we'd can query those definitively using compute_all_applicable_attributes instead:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Molts d'aquests mètodes es relacionen amb atributs, però podem demanar aquests definitivament utilitzant compute_all_applicable_attributes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is a set of Moose::Meta::Attribute objects.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El resultat és un conjunt d'objectes Moose::Meta::Attribute.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can map them through name as before to get the names:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem utilitzar el «map« sobre name com abans per aconseguir els noms:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can also see if they have setters:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>També podem veure si tenen «setters»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that only color has a setter: the other two are read-only, so this makes sense.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Observeu que només color té un «setter»: els altres dos no són modificables, així que això té sentit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As noted above, Moose is still being actively developed, but is production ready as long as you stick with things that work.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tal com s'ha comentat abans, Moose encara està sent desenvolupat de forma activa, però és production ready mentre us mantingueu en les coses que funcionen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll find the latest Moose in the CPAN, along with some other core plugins, typically in the MooseX namespace.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Trobareu l'últim Moose al CPAN, juntament amb algun altre complement base, normalment a l'espai de noms MooseX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, MooseX::Getopt allows you to define your @ARGV processing using type coercion, type constraints, and all that jazz.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, MooseX::Getopt us permet definir el vostre procés de @ARGV utilitzant coacció de tipus, restriccions de tipus, i totes aquestes coses.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I haven't had time to play with that yet, but it's on my to-do list, so perhaps I'll cover that in a future column.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>No he tingut temps per jugar-hi encara, però està a la meva llista de coses pendents, així que potser en parlaré a una columna futura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, MooseX::Object::Pluggable makes it easy to write classes that are pluggable, meaning that they can work well with plugins that define additional methods and attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>De forma similar, MooseX::Object::Pluggable simplifica l'escriptura de classes que són pluggable, que significa que poden treballar bé amb complements que defineixen mètodes i atributs adicionals.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Think of a generic web server or IRC bot object that has individually selectable additional behaviors.) Again, I'm just noticing these, and they look like they are worthy of their own descriptions later.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>(Penseu en un servidor web genèric o un «bot« IRC que té comportaments adicionals seleccionables individualment.) De nou, m'estic adonant ara d'aquests, i sembla que valgui la pena fer-ne una descripció especial més tard.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that Moose is itself built on Class::MOP, which is a framework for making class frameworks.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Observeu a més que el mateix Moose està construit sobre Class::MOP, que és un entorn de treball per crear entorns de treball de classes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perhaps other projects besides Moose will be using Class::MOP as a starting point as well.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Potser altres projectes a més de Moose també utilitzaran Class::MOP com a punt de partida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the infrastructure of Class::Prototyped (which I use in my own CGI::Prototype) might be built on Class::MOP, giving it more flexibility and robustness.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, l'infraestructura de Class::Prototyped (que utilitzo al meu CGI::Prototype) podria construir-se sobre Class::MOP, proporcionant més flexibilitat i robustesa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I hope you've enjoyed this two-part introduction to Moose.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Espero que hagueu gaudit d'aquesta introducció en dues parts a Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Have fun playing with a production-ready flexible object-building system.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Divertiu-vos jugant amb un sistema de construcció d'objectes flexible preparat per a producció.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until next time, enjoy!</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins aleshores, gaudiu!</seg>
      </tuv>
    </tu>
  </body>
</tmx>
