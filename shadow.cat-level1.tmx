<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="1.8.1_2"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN-US"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN-US">
        <seg>Linux Magazine Column 94 (Jun 2007)</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Columna 94 del Linux Magazine (juny de 2007)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[suggested title: ``The Moose is Flying (part 1)'']</seg>
      </tuv>
      <tuv lang="CA">
        <seg>[títol suggerit: «El Moose està volant (1a part)»]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perl's object system is very ``flexible'', meaning, you get to build it from the ground up.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El sistema d'objectes de Perl és molt «flexible», és a dir, es construeix de baix cap a dalt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can build traditional hash-based objects, or more exotic array-based or inside-out objects.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podeu construir objectes tradicionals basats en taules de dispersió, o objectes més exòtics basats en matrius o objectes capgirats.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And then you have to create the accessors, define access policies, and perform a lot of repetitive code.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Aleshores heu de crear els mètodes accessors, definir les polítiques d'accés i generar un munt de codi repetit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Luckily, Perl is introspective enough that you can get Perl to do most of the hard boring work.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Afortunadament, Perl és prou introspectiu com perquè li encomaneu la majoria del treball dur i avorrit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This has resulted in a number of ``class frameworks'' finding their way onto the CPAN.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això ha provocat que un bon nombre «d'entorns de treball per a classes» hagin estat publicats al CPAN.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Moose framework appeared about a year ago, and I initially dismissed it as ``yet another class framework'', much in the same way as I feel about yet another templating system or object-relational mapper.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>L'enton de treball Moose va sorgir fa un any i inicialment jo el vaig descartar com «un altre entorn de treball per a classes», de la mateixa manera que un altre sistema de plantilles o un altre mapeig d'objectes relacional em fan sentir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, I recently took a look at what Moose had become, and was pleasantly surprised.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tanmateix, vaig fer un cop d'ull recentment al que s'havia convertit Moose i em vaig endur una sorpresa agradable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As I started playing with it, I exclaimed frequently that this framework would have saved me quite a bit of time on some past projects, such as the text I wrote for our Intermediate Perl course and book, parts of which have been included as the perlboot manpage in the distribution.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Així que em vaig posar a jugar-hi, sovint vaig exclamar que aquest entorn de treball m'hauria estalviat un bona pila de temps en alguns projectes passats, com ara el text que vaig escriure per al nostre curs i llibre Intermediate Perl, algunes parts del qual s'han inclòs com la pàgina de manual perlboot a la distribució.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's recreate the ``animal'' classes from that text, using Moose, to see how this emerging framework simplifies things.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Posem-nos a refer les classes «d'animals» d'aquell text utilitzant Moose per veure com aquest entorn de treball emergent simplifica les coses.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, we'll create a horse class in Horse.pm that has a name and a color:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Primer crearem la classe cavall a Horse.pm que té un nom i un color:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Bringing in Moose defines has, which takes the name of an attribute along with its properties.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Incorporant Moose es defineix has, al qual se li passa el nom d'un atribut juntament amb les seves propietats.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Here, we're saying that the two attributes are ``read/write''.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest cas, diem que els dos atributs són de «lectura/escriptura».</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can now use this class:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara podem utilitzar aquesta classe:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that I didn't have to define a new method: Moose does that for me.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fixeu-vos que no m'ha calgut definir un mètode new: Moose ho fa per mi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now in the original text, Horse inherited from Animal.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En el text original Horse heretava d'Animal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can do that rather simply.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem fer això molt fàcilment.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Animal.pm, we place:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Posem a Animal.pm:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And then update our Horse.pm:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I aleshores actualitzem el nostre Horse.pm:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that extends here replaces the traditional use base and completely sets @ISA, rather than adding to it.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fixeu-vos que aquí extends substitueix el tradicional use base i fixa completament @ISA, enlloc d'afegir-hi un element.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(It's possible that you might want to put this inside a BEGIN block, although I've not seen any examples requiring it yet.)</seg>
      </tuv>
      <tuv lang="CA">
        <seg>(És possible que vulgueu posar això dins d'un bloc BEGIN, tot i que encara no he vist cap exemple que ho necessiti).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, Horse and Animal are identical.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest punt, Horse i Animal són idèntics.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They can both be instantiated, and have the two given attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els dos es poden instanciar i se'ls pot assignar atributs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the original example, what distinguished a horse was the sound it made, which we can add here:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En l'exemple original, el que distingia un cavall era el so que feia, cosa que podem afegir aquí:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>and then reference that in the common speak method in Animal:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>i aleshores fer-hi referència al mètode comú speak d'Animal:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note the use of confess, another freebie from Moose.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fixeu-vos en l'ús de confess, un altre regal de Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the derived class hasn't defined a sound, I want to complain.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si la classe derivada no ha definit un so, vull queixar-me.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But since Horse defines sound, I'll never see that for a horse.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Però com que Horse defineix sound, no veure mai això per un cavall.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With this code, I can create my classic talking horse:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb aquest codi puc crear el meu clàssic cavall parlador:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, I'm still coding things that would be simple without Moose, so let's start diverging a bit to see the full power.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins ara només estic programant coses que serien senzilles sense Moose, així que comencem a fer alguns canvis per veure'n tot el poder.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, an Animal is really an abstract class, being used only to provide common attributes and methods to a concrete class (in this case, the horse class).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Primer, un Animal és en realitat una classe abstracta, utilitzada només per proveïr atributs i mètodes comuns per a una classe concreta (en aquest cas, la classe cavall).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In Moose-terminology, this can best be described as a role.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En la terminologia de Moose això es descriu millor com un rol.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role is like a mix-in, providing a collection of attributes and methods that use those attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol és com un mix-in, que proveeix una col·lecció d'atributs i mètodes que utilitzen aquells atributs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role never has any instances, because it's not a complete class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol mai té cap instància perquè no és una classe completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When we make Animal a role, we'll also get some additional support:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Quan fem que Animal sigui un rol també obtenim suport addicional:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that we've replaced the confess-including stub with requires.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fixeu-vos que hem substituït l'«stub» que incloïa el confess per un requires.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This informs Moose that this role must now be used with a class that provides the sound method, which will be checked at compile-time.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això informa a Moose que les classes que usin aquest rol han de proveir el mètode sound, que serà verificat en temps de compilació.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To pull in a role, we use with rather than extends:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per atorgar un rol utilitzem with enlloc d'extends:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Had we failed to include sound, we'd get notification very early on.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si ens haguéssim oblidat d'incloure sound hauríem rebut un avís de bon començament.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Cool.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Genial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, Horse otherwise still works as before.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest punt, Horse segueix funcionant com abans.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What about those with and requires keywords?</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Què passa amb les paraules clau with i requires?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Because they're defined by the Moose and Moose::Role imports, they remain as part of the package.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Com que estan definits per les importacions de Moose i Moose::Role, romandran com a part del paquet.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For the purists in us who don't like that kind of pollution, we can throw them away when we're done, using the correponding no keyword (similiar to use strict and no strict).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per als puristes com nosaltres als que no ens agrada aquest tipus de pol·lució, podem eliminar-los quan hàgim acabat utilitzant la paraula clau no (de forma similar a use strict i no strict).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, we'd clean up Horse.pm with:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, podem netejar Horse.pm amb:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And similarly, Animal.pm requires no Moose::Role at the end.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I de forma similar, Animal.pm necessita no Moose::Role al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose supports the notion of a default value.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Moose ofereix suport per a la noció de valor predeterminat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's add in the default color, and make that a class responsibility as well:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Afegim el color predeterminat i fem que això també sigui responsabilitat de la classe:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the color isn't provided, the default color of the class will be consulted, and requires ensures that the concrete class provides this default color.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si no s'indica el color, es consultarà el color predeterminat de la classe i requires garanteix que la classe concreta proveeix aquest color predeterminat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our derived animal classes now look like:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Les nostres classes derivades ara tenen aquest aspecte:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now we can count sheep as one of our implemented classes:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara «ovella» és una més de les nostres classes implementades:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Well, this is pretty straightforward.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Bé, això és força pim pam.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's solve a few other problems from the original material.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Anem a resoldre alguns dels altres problemes del material original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The Mouse class was special, because it extended the speak method with an additional line of output.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>La classe Mouse era especial perquè extenia el mètode speak amb una línia addicional de sortida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While we could use traditional SUPER::-based method calls to call parent-class behaviors, this doesn't work with roles.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tot i que podríem utilitzar els mètodes tradicionals basats en SUPER:: per cridar els comportaments de la classe pare, això no funciona amb els rols.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Roles don't end up in @ISA, because they're ``glued in'' rather than ``tacked above''.)</seg>
      </tuv>
      <tuv lang="CA">
        <seg>(Els rols no acaben dins de @ISA perquè estan «empegats per dins» enlloc d'«enganxats al damunt»).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Luckily, Moose provides the convenient after call to append additional steps to an existing subroutine.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Afortunadament, Moose ofereix convenientment la crida after per afegir passes addicionals al final d'una subrutina existent.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose does this by replacing the original subroutine with a new subroutine that calls the original routine and then calls the additional code.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Moose fa això substituint la subrutina original per una nova subrutina que crida l'orginal i tot seguit crida al codi addicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The context (list, scalar, or void) is properly preserved, as is the original return value.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El context (llista, escalar, o buit) es conserva de forma adequada, així com també el valor de retorn original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our amended speak looks something like:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El nostre speak retocat té aquesta pinta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This gives us a properly functioning mouse:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això ens dóna un ratolí que funciona correctament:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which results in:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>que dóna com a resultat:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can also use before and around to precede the original behavior or control the calling of the original behavior, as necessary.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>També podem utilitzar before per a precedir el comportament original o around per a controlar com es crida el comportament original, segons calgui.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, to allow name to be used as both an accessor and still return an unnamed Horse when used as a class method, we can ``around'' the resulting name accessor:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, per a permetre que name s'utilitzi com un mètode accessor però que segueixi retornant an unnamed Horse quan s'utilitzi com un mètode de classe, podem posar un «around» del mètode accessor resultant:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The has creates the original behavior.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El has crear el comportament original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The around intercepts the original subroutine name, causing the original coderef to be passed as the first parameter to this new subroutine, which we capture in $next.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>L'around intercepta el nom de la subroutina original, fent que la referència al codi original es passi com a primer paràmetre d'aquesta nova subrutina, que nosaltres capturem a $next.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The original $self is shifted away, and tested to see if it's an object or not, via blessed (conveniently exported via Moose).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Desencuem el $self original i el verifiquem per veure si és un objecte o no, via blessed (exportat per Moose convenientment).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For a blessed object, we get the original behavior (a getter or setter), but for a class, we'll get the literal string.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per a un objecte obtenim el comportament original (un «getter» o «setter»), però per a una classe obtindrem la cadena literal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>What if we never gave our animal a name?</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Què passa si no li posem un nom al nostre animal?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We'll get warnings about undefined values.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Obtindrem avisos sobre valors indefinits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can give a default name just as we did a default color:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem assignar un nom predeterminat tal com vam fer amb el color predeterminat:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Again, we'd want that around immediately following this step.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Novament, voldríem aquell around immediatament després d'aquest pas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we don't want people setting the color after the initial instance creation, we can declare the attribute as read-only:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si no volem que la gent canviï el color després de la creació inicial de la instància, declarem l'atribut no modificable:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now an attempt to set the color is aborted with Cannot assign a value to a read-only accessor....</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara un intent de canviar el color s'avortarà amb Cannot assign a value to a read-only accessor....</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If we really wanted to have a way to occasionally set the color, we can define a separately named writer:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si realment volíem una manera de canviar el color ocasionalment, podem definir a banda un anomenat escriptor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Thus, we can't change the color of a mouse directly:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>D'aquesta manera no podem canviar el color d'un ratolí directament:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But we can use our private name instead:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Però en canvi podem utilitzar un mètode privat:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By using a long name, we're less likely to accidentally call it, except where we intentionally want to change the color.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tot utilitzant un nom llarg és menys probable que el cridem accidentalment, a menys que tinguem la intenció de canviar el color.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Let's create a RaceHorse by adding ``race features'' to a Horse.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Anem a crear un RaceHorse afegint «característiques de carrera» a un Horse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>First, we define the ``race features'' as, yes, another role:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Primer definim «característiques de carrera» com, sí, un altre rol:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that since has is just a subroutine call, we can use traditional Perl control structures (here, a foreach loop).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Com que has és només una crida a una subrutina, fixeu-vos que podem utilitzar estructures de control tradicionals de Perl (aquí, un bucle foreach).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With a bit of code, we've added another four attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb una mica de codi hem afegit uns altres quatre atributs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The initial value of 0 means we don't have to write separate initialization code in our constructor.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El valor inicial 0 significa que no ens caldrà escriure per separat codi d'inicialització al nostre constructor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next, we can add some accessors:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tot seguit podem afegir alguns mètodes accessors:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Each call to won increments the number of wins.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Cada crida a won incrementa el número de victòries.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This would be simpler if we presumed that these objects are implemented as hashes (which they are by default), as:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això seria més senzill si assumíssim que aquests objectes s'implementen amb taules de dispersió (per defecte és així), com ara:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, by using the public interface (a method call), we could change the implementation later to inside-out objects or array-based objects without breaking this code.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tanmateix, utilitzant la interfície pública (una crida al mètode) podríem canviar més endavant la implementació amb objectes capgirats o objectes basats en matrius sense trencar aquest codi.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is especially important when creating a generic role, which could be mixed in to any kind of object.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això és especialment important quan es crea un rol genèric, que es podria mesclar amb qualsevol tipus d'objecte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>To create the race horse, we just mix a horse with a racer:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per a crear la carrera de cavalls només cal que mesclem un cavall amb un corredor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And now we can ride the ponies:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I ara ja podem cavalcar els ponis:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So far, I've just scratched the surface of what Moose provides.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins ara només he rascat la superfície del que proporciona Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Next month, I'll look at some of the more advanced features of Moose that help keep the complex things relatively simple.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El proper mes miraré algunes de les característiques més avançades de Moose que ajuden a mantenir les coses complexes de manera relativament simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until then, enjoy!</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins aleshores, gaudiu!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Randal L. Schwartz is a renowned expert on the Perl programming language (the lifeblood of the Internet), having contributed to a dozen top-selling books on the subject, and over 200 magazine articles.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Randal L. Schwartz és un expert de renom sobre el llenguatge de programació Perl (l'essència vital d'Internet), que ha contribuït en una dotzena de llibres supervendes en la matèria i més de 200 articles en revistes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Schwartz runs a Perl training and consulting company (Stonehenge Consulting Services, Inc of Portland, Oregon), and is a highly sought-after speaker for his masterful stage combination of technical skill, comedic timing, and crowd rapport.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En Schwartz té una empresa de formació i consultoria en Perl (Stonehenge Consulting Services, Inc de Portland, Oregon) i és un conferenciant molt buscat gràcies a la seva destresa damunt l'escenari, que combina coneixements tècnics, pauses dramàtiques i sintonia amb el públic.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And he's a pretty good Karaoke singer, winning contests regularly.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I és força bon cantant de Karaoke, que guanya concursos sovint.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Schwartz can be reached for comment at merlyn@stonehenge.com or +1 503 777-0095, and welcomes questions on Perl and other related topics.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podeu contactar en Schwartz per a comentaris a merlyn@stonehenge.com o al telèfon +1 503 777-0095, i accepta preguntes sobre Perl i d'altres temes relacionats.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>[suggested title: ``The Moose is Flying (part 2)'']</seg>
      </tuv>
      <tuv lang="CA">
        <seg>[títol suggerit: «El Moose està volant (2a part)»]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Last month, I introduced the Moose object system by walking through the code developed in the perlboot manpage, rewriting it to use Moose.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El mes passat, vaig introduir el sistema d'objectes Moose recorrent el codi desenvolupat a la pàgina de manual de perlboot , reescrivint-ho per utilitzar Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Continuing from that discussion, let's look at some of the features I didn't cover last month.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Continuant a partir d'aquella discussió, fem un cop d'ull a algunes de les característiques que no vaig cobrir el mes passat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our Animal role included attributes of name, and color, and actions of speak and eat.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El nostre rol Animal incloïa atributs de name i color, i mètodes de speak i eat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can add a birthdate attribute to the mix with:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem afegir un atribut d'aniversari a la barreja amb:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As we don't want to be able to change the birthdate, we'll make it read-only.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Com que no volem que es pugui canviar la data d'aniversari, farem que sigui no modificable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, this attribute accepts any scalar, so these are all equally valid:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per defecte, aquest atribut accepta qualsevol escalar, així que aquests són tots equivalentment vàlids:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can get a bit of help from Moose to narrow down the permissible type of this new birthdate attribute using Moose's typing system:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem aconseguir una mica d'ajuda de Moose per reduir el tipus permès d'aquest nou atribut aniversari utilitzant el sistema de tipus de Moose:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The isa parameter here declares that the born parameter must be a DateTime object, or at least something that responds true to UNIVERSAL::isa($thing, &quot;DateTime&quot;).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El paràmetre isa declara aquí que el paràmetre  born  ha de ser un objecte DateTime, o com a mínim algun tipus que respongui cert a UNIVERSAL::isa($thing, &quot;DateTime&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now, if we try to put anything in this born attribute other than a DateTime, we get a run-time error.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara, si intentem assignar qualsevol cosa a l'atribut born que no sigui un DateTime, obtenim un error en temps d'execució.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So, this fails:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Així doncs, això falla:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But this succeeds:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Però això funciona:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The DateTime string for isa refers here to the Perl class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>La cadena DateTime per isa es refereix aquí a la classe de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>However, we can also define this as an artificial Moose type:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tanmateix, també podem definir això com un tipus de Moose artificial:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This works like before, but now identifies DateTime as a Moose-type.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això funciona com abans, però ara identifica DateTime com un tipus de Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The type is created by starting with any Object, and then requiring that this object pass the additional qualification of being a subclass of Perl's DateTime.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El tipus es crea començant amb qualsevol Object i després requering que aquest objecte passi la qualificació adicional de ser una subclasse de DateTime de Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At this point, we could continue to use this Moose-style DateTime type as we had before.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest punt, podem continuar utilitzant aquest DateTime de Moose com ho fèiem abans.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But once we've done this, we can further subtype the type.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una vegada hem fet això, podem derivar un subtipus del tipus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, we can require that the date be a historical date (before now):</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, podem requerir que la data sigui històrica (prèvia al present):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now, not just any DateTime will do.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara no funcionarà qualsevol DateTime.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It has to be something that isn't in the future.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ha de ser algun moment que no sigui al futur.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The expression in where can be any expression returning a true/false value, using $_ as a proxy for the object in question.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>L'expressió al where pot ser qualsevol expressió que retorni un valor cert/fals, utilitzant $_ com a proxy per a l'objecte en qüestió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It'd be easier if we could still use casual forms like yesterday and 3/14/1929.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Seria més senzill encara si poguèssim utilitzar expressions informals com yesterday i 3/14/1929.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are both understood by Date::Manip.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Date::Manip enten aquestes dues.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We could parse the strings with Date::Manip, then pull out the component values and hand them to DateTime, but luckily, there's already a module to do that: DateTime::Format::DateManip.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem analitzar les cadenes amb Date::Manip, extreure els valors dels components i després entregar-los a DateTime, però afortunadament, ja hi ha un mòdul que fa això: DateTime::Format::DateManip.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not bad.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>No està malament.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our newbie horse is born yesterday, as we expect.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El nostre aprenent cavall va nèixer ahir, tal com esperàvem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>But it'd be nice to just drop yesterday into the slot and have it do all of that for us.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Però estaria bé simplement posar yesterday al paràmetre i deixar que ho faci tot per nosaltres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And with coercions, we can.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I amb coercions, podem fer-ho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Since passing a simple string as the birthtime is illegal, we can inform Moose that it should take that string and run it through DateTime::Format::DateManip automatically:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Com que passar una cadena com a aniversari no està permés, podem indicar a Moose que agafi la cadena i la passi per  DateTime::Format::DateManip automàticament:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The via code block takes $_ as the input value, which is expected to be a string (Str).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El bloc via agafa $_ com un valor d'entrada, que s'espera que sigui una cadena (Str).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The last expression evaluated in the code is the new HistoricalDateTime value.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>L'última expressió avaluada al codi és el nou valor HistoricalDateTime.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We then permit this coercion to be used by adding coerce into the attribute declaration:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Després permetem l'ús d'aquesta coacció afegint coerce  a la declaració de l'atribut:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Now, the born slot accepts either an explicit DateTime as before, or a simple string.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara el paràmetre born accepta o bé un DateTime explícit com abans, o bé una cadena simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The string must be acceptable to Date::Manip, which will be used to convert the string into a DateTime object as our object is created.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>La cadena ha de ser acceptable per Date::Manip, que serà utilitzat per convertir la cadena a un objecte DateTime quan el nostre objecte sigui creat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also, because the type constraint is still in place, the verification to ensure the result is a historical date is still active.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>A més, com que la coacció de tipus està a lloc, la verificació per assegurar que el resultat és una data històrica encara està activa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Besides the named classes and Str, Moose::Util::TypeConstraints also establishes types of things like Bool and HashRef.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>A més dels noms de les classes i Str, Moose::Util::TypeConstraints també estableix els tipus de coses com Bool i HashRef.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We could even have multiple coercions defined, as long as they are distinct.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins i tot podríem tenir múltiples coaccions definides, sempre i quan siguin diferents.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, we could use a hashref in the birthtime slot to indicate that we are passing key/value pairs to be handed to a DateTime constructor directly:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, podem utilitzar una referència a una taula de dispersió al paràmetre aniversari per indicar que estem passant parells clau/valor perquè siguin entregats directament a un constructor DateTime:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And now we can use a hashref to define the birthdate:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I ara podem definir una referència a una taula de dispersió per definir l'aniversari:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the value for born is a DateTime, it's used directly.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si el valor per a born és un DateTime, s'utilitza directament.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If it's a string, it's passed to DateTime::Format::DateManip.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si és una cadena, es passa a DateTime::Format::DateManip.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And if it's a hashref, it's passed directly as a flattened list to the DateTime constructor.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I si és una referència a una taula de dispersió, es passa directament com una llista aplanada al constructor DateTime.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Very cool.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Genial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The value we specify for a default is subject to the same coercions and type checking.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El valor que especifiquem per a default està subjecte a les mateixes coaccions i comprovacions de tipus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can update born as:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem actualitzar born a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>And now our animals default to being ``born yesterday''.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I ara, el valor per defecte dels animals a ``nascut ahir''.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the default value is still subject to the type constraints, so if we replace yesterday with tomorrow, the default value will be rejected properly.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Observeu que el valor per defecte encara està subjecte a les restriccions de tipus, per tant si substituïm yesterday per tomorrow, el valor per defecte serà rebutjat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that the coercion happens as each object is created, so a default value of one minute ago will give us a new time each time it is called.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Observeu que la coacció passa a mesura que cada objecte es crea, per tant el valor per defecte one minute ago ens donarà una data diferent cada vegada que sigui cridat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>While we're on things we can do to attributes, another interesting item is lazy.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Mentre estudiem què podem fer als atributs, un altre element interessant és lazy.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If the default value is expensive to compute, we can say ``don't really do this until you need to do it''.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si el valor per defecte és car de calcular, podem dir ``no facis això fins que ho necessitis''.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, turning yesterday into a DateTime is slightly expensive, so we can flag that as lazy:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, convertir yesterday a un objecte DateTime és una mica car, així que ho podem marcar com lazy:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Speaking of great support, as I was writing that last paragraph, I noticed a bug in the result, and chatting with Stevan on IRC got it fixed before I could turn this article in.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I parlant de suport fantàstic, mentre escrivia aquest últim pàrraf vaig descobrir un error de programació, i commentar-ho amb Stevan a l'IRC ho va solucionar abans que jo entregués l'article.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Yeay.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Visca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Anything built with Moose has a very high degree of introspection available.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Qualsevol cosa construïda amb Moose té disponible un grau molt alt d'introspecció.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, we can ask one of our animal friends to give us the meta object, with which we can make further requests:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, podem demanar a un dels nostres amics animals que ens doni l'objecte meta, amb el què podrem fer més peticions:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can ask the horse for the roles:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem demanar al cavall per els roles:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In this case, we see that we've mixed in one role (of type Moose::Meta::Role, and get the name with:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquest cas, veiem que hem obtingut un rol (de tipus Moose::Meta::Role), i aconseguit el nom amb:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which gives us Animal as we might expect.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>cosa que ens dona un Animal tal com esperàvem.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can also ask the meta object for all applicable methods:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem demanar a l'objecte meta tots els mètodes aplicables:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>which returns</seg>
      </tuv>
      <tuv lang="CA">
        <seg>cosa que retorna</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Nice.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Genial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Not sure what BEGIN is doing in there, but the rest are things that we've defined.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>No estic segur de què fa BEGIN aquí, però la resta són elements que hem definit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of these methods relate to the attributes, but we'd can query those definitively using compute_all_applicable_attributes instead:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Molts d'aquests mètodes es relacionen amb atributs, però podem demanar aquests definitivament utilitzant compute_all_applicable_attributes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The result is a set of Moose::Meta::Attribute objects.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El resultat és un conjunt d'objectes Moose::Meta::Attribute.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can map them through name as before to get the names:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podem utilitzar el «map« sobre name com abans per aconseguir els noms:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We can also see if they have setters:</seg>
      </tuv>
      <tuv lang="CA">
        <seg>També podem veure si tenen «setters»:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Note that only color has a setter: the other two are read-only, so this makes sense.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Observeu que només color té un «setter»: els altres dos no són modificables, així que això té sentit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>As noted above, Moose is still being actively developed, but is production ready as long as you stick with things that work.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Tal com s'ha comentat abans, Moose encara està sent desenvolupat de forma activa, però és production ready mentre us mantingueu en les coses que funcionen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You'll find the latest Moose in the CPAN, along with some other core plugins, typically in the MooseX namespace.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Trobareu l'últim Moose al CPAN, juntament amb algun altre complement base, normalment a l'espai de noms MooseX.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, MooseX::Getopt allows you to define your @ARGV processing using type coercion, type constraints, and all that jazz.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, MooseX::Getopt us permet definir el vostre procés de @ARGV utilitzant coacció de tipus, restriccions de tipus, i totes aquestes coses.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I haven't had time to play with that yet, but it's on my to-do list, so perhaps I'll cover that in a future column.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>No he tingut temps per jugar-hi encara, però està a la meva llista de coses pendents, així que potser en parlaré a una columna futura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Similarly, MooseX::Object::Pluggable makes it easy to write classes that are pluggable, meaning that they can work well with plugins that define additional methods and attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>De forma similar, MooseX::Object::Pluggable simplifica l'escriptura de classes que són pluggable, que significa que poden treballar bé amb complements que defineixen mètodes i atributs adicionals.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Think of a generic web server or IRC bot object that has individually selectable additional behaviors.) Again, I'm just noticing these, and they look like they are worthy of their own descriptions later.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>(Penseu en un servidor web genèric o un «bot« IRC que té comportaments adicionals seleccionables individualment.) De nou, m'estic adonant ara d'aquests, i sembla que valgui la pena fer-ne una descripció especial més tard.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Also note that Moose is itself built on Class::MOP, which is a framework for making class frameworks.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Observeu a més que el mateix Moose està construit sobre Class::MOP, que és un entorn de treball per crear entorns de treball de classes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Perhaps other projects besides Moose will be using Class::MOP as a starting point as well.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Potser altres projectes a més de Moose també utilitzaran Class::MOP com a punt de partida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, the infrastructure of Class::Prototyped (which I use in my own CGI::Prototype) might be built on Class::MOP, giving it more flexibility and robustness.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, l'infraestructura de Class::Prototyped (que utilitzo al meu CGI::Prototype) podria construir-se sobre Class::MOP, proporcionant més flexibilitat i robustesa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>I hope you've enjoyed this two-part introduction to Moose.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Espero que hagueu gaudit d'aquesta introducció en dues parts a Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Have fun playing with a production-ready flexible object-building system.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Divertiu-vos jugant amb un sistema de construcció d'objectes flexible preparat per a producció.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Until next time, enjoy!</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Fins aleshores, gaudiu!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 NAME</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head1 NAME/NOM</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 AUTHOR</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head1 AUTOR</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 COPYRIGHT AND LICENSE</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head1 COPYRIGHT I LLICÈNCIA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Aquesta llibreria és programari lliure; podeu redistribuir-la i/o modificar-la amb les mateixes condicions del propi Perl.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose::Manual::Concepts - Moose OO concepts</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Moose::Manual::Concepts - Conceptes d'OO a Moose</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 MOOSE CONCEPTS (VS &quot;OLD SCHOOL&quot; Perl)</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head1 CONCEPTES DE MOOSE (contra Perl &quot;de la vella escola&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In the past, you may not have thought too much about the difference
between packages and classes, attributes and methods, constructors and
methods, etc.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En el passat potser no heu pensat massa en la diferència entre paquets i classes, atributs i mètodes, constructors i mètodes, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With Moose, these are all conceptually separate things,
even though under the hood they're implemented with plain old Perl.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb Moose totes aquestes són coses conceptualment separades, tot i que internament s'implementa amb Perl tradicional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Our meta-object protocol (aka MOP) provides well-defined introspection
features for each of those concepts, and Moose in turn provides
distinct sugar for each of them.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El nostre protocol de meta-objectes (també conegut com MOP) ofereix característiques d'introspecció ben definides per a cadascun d'aquests conceptes, i al seu torn Moose ofereix una diferent sintaxi ensucrada per a cadascun d'ells.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose also introduces additional
concepts such as roles, method modifiers, and declarative delegation.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Moose també introdueix conceptes addicionals com ara els rols, els modificadors de mètodes i la delegació declarativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Knowing what these concepts mean in Moose-speak, and how they used to
be done in old school Perl 5 OO is a good way to start learning to use
Moose.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Conèixer el que volen dir aquests conceptes en l'argot de Moose i com s'acostumaven a utilitzar en l'OO de Perl 5 de la vella escola és una bona manera de començar a aprendre a utilitzar Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Class</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head2 Classe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you say &quot;use Moose&quot; in a package, you are making your package a
class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Quan dieu &quot;use Moose&quot; en un paquet, esteu convertint en vostre paquet en una classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At its simplest, a class will consist simply of attributes
and/or methods.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>La manera més simple de definir una classe consistirà únicament d'atributs i/o mètodes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It can also include roles, method modifiers, and more.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>També pot incloure rols, modificadors de mètodes i més.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class I&lt;has&gt; zero or more B&lt;attributes&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una classe I&lt;té&gt; zero o més B&lt;atributs&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class I&lt;has&gt; zero or more B&lt;methods&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una classe I&lt;té&gt; zero o més B&lt;mètodes&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class I&lt;has&gt; zero or more superclasses (aka parent classes).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una classe I&lt;té&gt; zero o més superclasses (o classes pare).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A
class inherits from its superclass(es).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una classe hereta de les seves superclasses.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class I&lt;has&gt; zero or more B&lt;method modifiers&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una classe I&lt;té&gt; zero o més B&lt;modificadors de mètodes&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These modifiers can
apply to its own methods or methods that are inherited from its
ancestors.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Aquests modificadors es poden aplicar als seus propis mètodes o als mètodes heretats dels seus ancestres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class I&lt;does&gt; (and I&lt;consumes&gt;) zero or more B&lt;roles&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una classe I&lt;fa&gt; (i I&lt;consumeix&gt;) zero o més B&lt;rols&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class I&lt;has&gt; a B&lt;constructor&gt; and a B&lt;destructor&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una classe I&lt;té&gt; un B&lt;constructor&gt; i un B&lt;destructor&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are
provided for you &quot;for free&quot; by Moose.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Aquests us els ofereix Moose de franc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>The B&lt;constructor&gt; accepts named parameters corresponding to the
class's attributes and uses them to initialize an B&lt;object instance&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>El B&lt;constructor&gt; accepta paràmetres amb nom que corresponguin als atributs de la classe i els utilitza per inicialitzar una B&lt;instància de l'objecte&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class I&lt;has&gt; a B&lt;metaclass&gt;, which in turn has B&lt;meta-attributes&gt;,
B&lt;meta-methods&gt;, and B&lt;meta-roles&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una classe I&lt;té&gt; una B&lt;meta-classe&gt;, que al seu torn té B&lt;meta-atributs&gt;, B&lt;meta-mètodes&gt;, i B&lt;meta-rols&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This metaclass I&lt;describes&gt; the
class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Aquesta meta-classe I&lt;descriu&gt; la classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A class is usually analogous to a category of nouns, like &quot;People&quot; or
&quot;Users&quot;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una classe normalment és anàloga a una categoria de noms, com ara &quot;Persones&quot; o &quot;Usuaris&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg># now it's a Moose class!</seg>
      </tuv>
      <tuv lang="CA">
        <seg># ara és una classe de Moose!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Attribute</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head2 Atribut</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An attribute is a property of the class that defines it.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un atribut és una propietat que defineix una classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It I&lt;always&gt;
has a name, and it I&lt;may have&gt; a number of other properties.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>I&lt;Sempre&gt; té un nom i I&lt;pot tenir&gt; d'altres propietats.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These properties can include a read/write flag, a B&lt;type&gt;, accessor
method names, B&lt;delegations&gt;, a default value, and more.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Aquestes propietats inclouen un indicador de lectura/escriptura, un B&lt;tipus&gt;, noms dels mètodes accessors, B&lt;delegacions&gt;, un valor predeterminat, i més.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Attributes I&lt;are not&gt; methods, but defining them causes various
accessor methods to be created.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els atributs I&lt;no són&gt; mètodes, però en definir-los es creen diversos mètodes accessors.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>At a minimum, a normal attribute will
always have a reader accessor method.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Com a mínim, un atribut normal tindrà sempre un mètode accessor de lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many attributes also have other
methods, such as a writer method, clearer method, and predicate method
(&quot;has it been set?&quot;).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Molts atributs també tenen altres mètodes, com ara un mètode d'escriptura, un mètode de neteja, i un mètode de predicat (&quot;s'ha establert?&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An attribute may also define B&lt;delegations&gt;, which will create
additional methods based on the delegation mapping.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un atribut també pot definir B&lt;delegacions&gt;, que crearan mètodes addicionals basats en el mapatge de delegacions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>By default, Moose stores attributes in the object instance, which is a
hashref, I&lt;but this is invisible to the author of a Moose-based
class&gt;!</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per defecte, Moose emmagatzema els atributs a la instància de l'objecte, què és una referència a una taula de dispersió, I&lt;però això és invisible a l'autor d'una classe basada en Moose&gt;!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It is best to think of Moose attributes as &quot;properties&quot; of
the I&lt;opaque&gt; B&lt;object instance&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>És millor pensar en els atributs de Moose com a &quot;propietats&quot; de la B&lt;instància I&lt;opaca&gt; de l'objecte&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These properties are accessed
through well-defined accessor methods.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Aquestes propietats s'accedeixen mitjançant mètodes accessors ben definits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An attribute is something that the class's members have.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un atribut és quelcom que tenen els membres de la classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example,
People have first and last names.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, les persones tenen nom i cognom.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Users have passwords and last login
datetimes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els usuaris tenen contrasenyes i la data i hora de darrera connexió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Method</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head2 Mètode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A B&lt;method&gt; is very straightforward.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un B&lt;mètode&gt; és força pim pam.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Any subroutine you define in your
class is a method.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Qualsevol subrutina que definiu a la vostra classe és un mètode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>B&lt;Methods&gt; correspond to verbs, and are what your objects can do.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els B&lt;mètodes&gt; es corresponen amb verbs i són el que els vostres objectes poden fer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example, a User can login.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, un Usuari pot connectar-se.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Roles</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head2 Rols</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role is something that a class I&lt;does&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol és quelcom que una classe I&lt;fa&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>We also say that classes
I&lt;consume&gt; roles.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Diem que les classes I&lt;consumeixen&gt; rols.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a Machine class might do the Breakable
role, and so could a Bone class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, una classe Màquina podria fer el rol Trencable, tal com podria fer-ho una classe Os.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role is used to define some concept
that cuts across multiple unrelated classes, like &quot;breakability&quot;, or
&quot;has a color&quot;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol s'utilitza per definit algun concepte que s'aplica a múltiples classes que no estan relacionades, com ara la &quot;trencabilitat&quot;, o
&quot;té un color&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role I&lt;has&gt; zero or more B&lt;attributes&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol I&lt;té&gt; zero o més B&lt;atributs&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role I&lt;has&gt; zero or more B&lt;methods&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol I&lt;té&gt; zero o més B&lt;mètodes&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role I&lt;has&gt; zero or more B&lt;method modifiers&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol I&lt;té&gt; zero o més B&lt;modificadors de mètode&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role I&lt;has&gt; zero or more B&lt;required methods&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol I&lt;té&gt; zero o més B&lt;mètodes necessaris&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A required method is not implemented by the role.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un mètode necessari no s'implementa dins el rol.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Required methods say
&quot;to use this Role you must implement this method&quot;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els mètodes necessaris diuen &quot;per utilitzar aquest Rol heu d'implementar aquest mètode&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A role I&lt;has&gt; zero or more B&lt;excluded roles&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol I&lt;té&gt; zero o més B&lt;rols exclosos&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An excluded role is a role that the role doing the excluding says it
cannot be combined with.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un rol exclós és un rol que no es pot combinar amb el rol que indica l'exclusió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Roles are I&lt;composed&gt; into classes (or other roles).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els rols es I&lt;composen&gt; dins de les classes (o d'altres rols).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When a role is
composed into a class, its attributes and methods are &quot;flattened&quot; into
the class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Quan un rol es composa dins d'una classe els seus atributs i els seus mètodes se &quot;simplifiquen&quot; dins de la classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Roles I&lt;do not&gt; show up in the inheritance hierarchy.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els rols I&lt;no&gt; apareixen a la jerarquia de l'herència.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When
a role is composed, its attributes and methods appear as if they were
defined I&lt;in the consuming class&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Quan es composa un rol els seus atributs i mètodes apareixen com si s'haguessin definit I&lt;a la classe que el consumeix&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Role are somewhat like mixins or interfaces in other OO languages.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els rols són quelcom semblant als I&lt;mixins&gt; o les interfícies en altres llenguatges amb OO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Method modifiers</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head2 Modificadors de mètode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A B&lt;method modifier&gt; is a hook that is called when a named method is
called.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un B&lt;modificador de mètode&gt; és un ganxo que es crida quan es crida un mètode amb nom.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you could say &quot;before calling C&lt;login()&gt;, call
this modifier first&quot;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, podeu dir &quot;abans de cridar C&lt;login()&gt;, primer crideu aquest modificador&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Modifiers come in different flavors like
&quot;before&quot;, &quot;after&quot;, &quot;around&quot;, and &quot;augment&quot;, and you can apply more
than one modifier to a single method.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els modificadors tenen diferents aspectes com ara &quot;before&quot;, &quot;after&quot;, &quot;around&quot;, i &quot;augment&quot;, i podeu aplicar més d'un modificador a un sol mètode.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Method modifiers are often used as an alternative to overriding a
method in a parent class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els modificadors de mètode s'utilitzen sovint com a alternativa a sobreescriure un mètode d'una classe pare.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>They are also used in roles as a way of
modifying methods in the consuming class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>També s'utilitzen als rols com una manera de modificar els mètodes a la classe que els consumeix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Under the hood, a method modifier is just a plain old Perl subroutine
that gets called before or after (or around, etc.) some named method.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Internament, un modificador de mètode és una subrutina tradicional de Perl que s'executa abans o després (o enmig, etc.) d'algun mètode amb nom.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Type</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head2 Tipus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose also comes with a (miniature) type system.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Moose també duu un sistema de tipus (en miniatura).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This allows you to
define types for attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això us permet definir tipus per als atributs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose has a set of built-in types based
on what Perl provides, such as C&lt;Str&gt;, C&lt;Num&gt;, C&lt;Bool&gt;, C&lt;HashRef&gt;, etc.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Moose té un conjunt de tipus integrats que es basen en el que ofereix Perl, com ara C&lt;Str&gt;, C&lt;Num&gt;, C&lt;Bool&gt;, C&lt;HashRef&gt;, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In addition, every class name in your application can also be used as
a type name.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Addicionalment, cada nom de classe de la vostra aplicació també es pot utilitzar com un nom de tipus.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Finally, you can define your own types, either as subtypes or entirely
new types, with their own constraints.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Finalment, podeu definir els vostres propis tipus, ja siguin subtipus o tipus totalment nous, amb les seves pròpies restriccions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you could define a
type C&lt;PosInt&gt;, a subtype of C&lt;Int&gt; which only allows positive numbers.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, podeu definir un tipus C&lt;PosInt&gt;, un subtipus d'C&lt;Int&gt; que només permet números positius.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Delegation</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head2 Delegació</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose attributes provide declarative syntax for defining
delegations.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Els atributs de Moose ofereixen una sintaxi declarativa per a definir les delegacions.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A delegation is a method which calls some method on an
attribute to do its real work.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una delegació és un mètode que crida algun altre mètode d'un atribut per a fer la feina de veritat.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A constructor creates an B&lt;object instance&gt; for the class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un constructor crea una B&lt;instància de l'objecte&gt; per a una classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In old
school Perl, this was usually done by defining a method called
C&lt;new()&gt; which in turn called C&lt;bless&gt; on a reference.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En Perl de la vella escola això es feia normalment definint un mètode anomenat C&lt;new()&gt;, que al seu torn cridava C&lt;bless&gt; sobre una referència.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With Moose, this C&lt;new()&gt; method is created for you, and it simply
does the right thing.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb Moose, aquest mètode C&lt;new()&gt; es crea per a vosaltres i simplement fa el que ha de fer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You should never need to define your own
constructor!</seg>
      </tuv>
      <tuv lang="CA">
        <seg>No us hauria de caldre mai definir el vostre propi constructor!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Sometimes you want to do something whenever an object is created.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>De vegades voleu fer alguna cosa quan es crea un objecte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In
those cases, you can provide a C&lt;BUILD()&gt; method in your class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>En aquests casos podeu definir el mètode C&lt;BUILD()&gt; a la vostra classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose
will call this for you after creating a new object.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Moose el cridarà just després de crear un nou objecte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This is a special method called when an object instance goes out of
scope.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Aquest és un mètode especial que es crida quan una instància de l'objecte surt fora de context.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>You can specialize what your class does in this method if you
need to, but you usually don't.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Podeu refinar el que fa la vostra classe en aquest mètode si us cal, però normalment no us caldrà.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With old school Perl 5, this is the C&lt;DESTROY()&gt; method, but with
Moose it is the C&lt;DEMOLISH()&gt; method.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb el Perl de la vella escola s'utilitzava el mètode C&lt;DESTROY()&gt;, però amb Moose és el mètode C&lt;DEMOLISH()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Object instance</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head2 Herència d'objectes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An object instance is a specific noun in the class's &quot;category&quot;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una instància de l'objecte és un nom específic a la &quot;categoria&quot; de la classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For
example, one specific Person or User.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, una Persona o un Usuari específics.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance is created by the
class's B&lt;constructor&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una instància es crea amb el B&lt;constructor&gt; de la classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>An instance has values for its attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una instància té valors per als seus atributs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, a specific
person has a first and last name.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, una persona específica té un nom i un cognom.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>In old school Perl 5, this is often a blessed hash reference.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb Perl de la vella escola això normalment seria una referència beneïda a una taula de dispersió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With
Moose, you should never need to know what your object instance
actually is.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb Moose no us hauria de caldre mai saber quina és la vostra instància de l'objecte.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>(Okay, it's usually a blessed hashref with Moose, too.)</seg>
      </tuv>
      <tuv lang="CA">
        <seg>(D'acord, normalment també és una referència beneïda a una taula de dipsersió a Moose).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head2 Moose vs old school summary</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head2 Resum de Moose contra Perl de la vella escola</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * Class</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=item * Classe</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A package with no introspection other than mucking about in the symbol
table.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un paquet sense cap altra introspecció a banda de potinejar la taula de símbols.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With Moose, you get well-defined declaration and introspection.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb Moose obteniu una declaració i una introspecció ben definides.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * Attributes</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=item * Atributs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hand-written accessor methods, symbol table hackery, or a helper
module like C&lt;Class::Accessor&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Mètodes accessors escrits a mà, manipulació de la taula de símbols, o un mòdul d'ajuda com ara C&lt;Class::Accessor&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With Moose, these are declaratively defined, and distinct from
methods.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb Moose es defineixen d'una forma declarativa i diferent dels mètodes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * Method</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=item * Mètode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>These are pretty much the same in Moose as in old school Perl.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Són pràcticament iguals a Moose que a Perl de la vella escola.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * Roles</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=item * Rols</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Class::Trait&gt; or C&lt;Class::Role&gt;, or maybe C&lt;mixin.pm&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>C&lt;Class::Trait&gt; o C&lt;Class::Role&gt;, o potser C&lt;mixin.pm&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With Moose, they're part of the core feature set, and are
introspectable like everything else.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb Moose són part central del conjunt de característiques i se'n pot fer introspecció com en qualsevol altra cosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * Method Modifiers</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=item * Modificadors de mètode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Could only be done through serious symbol table wizardry, and you
probably never saw this before (at least in Perl 5).</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Només es podria aconseguir fent màgia amb la taula de símbols, i segurament no ho havíeu vist mai fins ara (si més no a Perl 5).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * Type</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=item * Tipus</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Hand-written parameter checking in your C&lt;new()&gt; method and accessors.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Comprovació a mà dels paràmetres als vostres mètodes C&lt;new()&gt; i als accessors.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With Moose, you define types declaratively, and then use them by name
in your attributes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb Moose definiu els tipus de forma declarativa i aleshores els utilitzeu pel nom en els vostres atributs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * Delegation</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=item * Delegació</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>C&lt;Class::Delegation&gt; or C&lt;Class::Delegator&gt;, but probably even more
hand-written code.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>C&lt;Class::Delegation&gt; o C&lt;Class::Delegator&gt;, però probablement encara més codi escrit a mà.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With Moose, this is also declarative.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb Moose això també és declaratiu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;new()&gt; method which calls C&lt;bless&gt; on a reference.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un mètode C&lt;new()&gt; que crida C&lt;bless&gt; sobre una referència.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Comes for free when you define a class with Moose.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>És gratis quan definiu una classe amb Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A C&lt;DESTROY()&gt; method.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Un mètode C&lt;DESTROY()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With Moose, this is called C&lt;DEMOLISH()&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb Moose s'anomena C&lt;DEMOLISH()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * Object Instance</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=item * Instància de l'objecte</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A blessed reference, usually a hash reference.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una referència beneïda, normalment una referència a una taula de dispersió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With Moose, this is an opaque thing which has a bunch of attributes
and methods, as defined by its class.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb Moose es tracta d'una cosa opaca que té un seguit d'atributs i mètodes, segons s'hagi definit la classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=item * Immutabilization</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=item * Immutabilitat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Moose comes with a feature called &quot;immutabilization&quot;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Moose té una característica anomenada &quot;immutabilitat&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>When you make
your class immutable, it means you're done adding methods, attributes,
roles, etc.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Quan feu la vostra classe immutable, significa que heu acabat d'afegir-hi mètodes, atributs, rols, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This lets Moose optimize your class with a bunch of
extremely dirty in-place code generation tricks that speed up things
like object construction and so on.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això permet que Moose optimitzi la vostra classe amb un seguit de trucs de generació de codi extremadament bruts que acceleren coses com ara la construcció d'objectes i tota la pesca.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 META WHAT?</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head1 META QUÈ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>A metaclass is a class that describes classes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una meta-classe és una classe que descriu d'altres classes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>With Moose, every class
you define gets a C&lt;meta()&gt; method.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Amb Moose cada classe que definiu té un mètode C&lt;meta()&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>It returns a L&lt;Moose::Meta::Class&gt;
object, which has an introspection API that can tell you about the
class it represents.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Retorna un objecte L&lt;Moose::Meta::Class&gt;, que té una API d'introspecció que us pot parlar sobre la classe que representa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Almost every concept we defined earlier has a meta class, so we have
L&lt;Moose::Meta::Class&gt;, L&lt;Moose::Meta::Attribute&gt;,
L&lt;Moose::Meta::Method&gt;, L&lt;Moose::Meta::Role&gt;,
L&lt;Moose::Meta::TypeConstraint&gt;, L&lt;Moose::Meta::Instance&gt;, and so on.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Gairebé qualsevol concepte que hem definit fins ara té una meta-classe, així tenim L&lt;Moose::Meta::Class&gt;, L&lt;Moose::Meta::Attribute&gt;, L&lt;Moose::Meta::Method&gt;, L&lt;Moose::Meta::Role&gt;, L&lt;Moose::Meta::TypeConstraint&gt;, L&lt;Moose::Meta::Instance&gt;, etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 BUT I NEED TO DO IT MY WAY!</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head1 PERÒ NECESSITO FER-HO A LA MEVA MANERA!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>One of the great things about Moose is that if you dig down and find
that it does something the &quot;wrong way&quot;, you can change it by extending
a metaclass.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Una de les coses grans de Moose és que si caveu prou fons i trobeu que fa alguna cosa &quot;malament&quot;, podeu canviar-ho extenent una meta-classe.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>For example, you can have arrayref based objects, you can
make your constructors strict (no unknown parameters allowed!), you can
define a naming scheme for attribute accessors, you can make a class a
Singleton, and much, much more.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Per exemple, podeu tenir objectes basats en referències a una matriu, podeu fer que els vostres constructors siguin estrictes (no acceptaran paràmetres desconeguts!), podeu definir l'esquema per anomenar els accessors dels atributs, podeu fer que una classe tingui el patró Singleton i moltíssimes més coses.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Many of these extensions require surprisingly small amounts of code,
and once you've done it once, you'll never have to hand-code &quot;your way
of doing things&quot; again.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Sorprenentment, moltes d'aquestes extensions només necessiten quantitats petites de codi i, un cop ho heu fet una vegada, no us caldrà programar a mà &quot;la vostra manera de fer-ho&quot; mai més.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Instead you'll just load your favorite
extensions.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Només caldrà que carregueu les vostres extensions preferides.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>=head1 WHAT NEXT?</seg>
      </tuv>
      <tuv lang="CA">
        <seg>=head1 I ARA QUÈ?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>So you're sold on Moose.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ja us hem venut Moose.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Time to learn how to really use it.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Ara és hora d'aprendre realment a utilitzar-lo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you want to see how Moose would translate directly into old school
Perl 5 OO code, check out L&lt;Moose::Manual::Unsweetened&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si voleu veure com faríeu el que feu amb Moose però amb OO de Perl 5 de la vella escola, feu un cop d'ull a L&lt;Moose::Manual::Unsweetened&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>This might be
helpful for quickly wrapping your brain around some aspects of &quot;the
Moose way&quot;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Això pot ser útil per tal que el vostre cervell s'acostumi a &quot;la manera de Moose&quot; d'enfocar algunes coses.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>Or you can skip that and jump straight to L&lt;Moose::Manual::Classes&gt;
and the rest of the L&lt;Moose::Manual&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>O podeu saltar-vos-ho i saltar directament a L&lt;Moose::Manual::Classes&gt; i la resta del L&lt;Moose::Manual&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After that we recommend that you start with the L&lt;Moose::Cookbook&gt;.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Després, us recomanem que comenceu amb el L&lt;Moose::Cookbook&gt;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If
you work your way through all the recipes under the basics section,
you should have a pretty good sense of how Moose works, and all of its
basic OO features.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si aconseguiu passar més enllà de les receptes de la secció de conceptes bàsics, hauríeu de tenir una bona idea de com funciona Moose i totes les seves característiques d'OO.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>After that, check out the Role recipes.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Després, feu un cop d'ull a les receptes de rols.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN-US">
        <seg>If you're really curious, go
on and read the Meta and Extending recipes, but those are mostly there
for people who want to be Moose wizards and change how Moose works.</seg>
      </tuv>
      <tuv lang="CA">
        <seg>Si realment teniu curiositat, seguiu llegint les receptes de Meta i Extending, però aquelles són principalment per volen ser mags de Moose i canviar la manera com funciona Moose.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
